#summary How to read data written to an OutputStream from an InputStream.
#labels Featured

= Introduction =

Sometimes a library writes its results to an `OutputStream` and you need to read them back from an `InputStream`. The common answer is "use pipes". But it's not as easy at is seems. Classes in the com.iotools.stream package should help.

= Details =
This code was inspired by the following article: http://ostermiller.org/convert_java_outputstream_inputstream.html

Two main classes in this section are `InputStreamFromOutputStream` and `OutputStreamToInputStream`

== !InputStreamFromOutputStream ==
This abstract class must be extended and the metod produce() implemented.
The data who is produced inside the function produce() is written to an `OutputStream` and can be readed back from from this class.
This is the preferred way to convert data written from an `OutputStream` into an `InputStream`, because the behaviour of the code tends to be more clear.

Sample usage:

{{{

final String dataId=//id of some data.
final InputStreamFromOutputStream isos = new InputStreamFromOutputStream() {
   @Override
   public void produce(final OutputStream dataSink) throws Exception {
      /*
       * call your application function who produces the data here
       * WARNING: we're in another thread here, so this method shouldn't 
       * write any class field or make assumptions on the state of the class.
       */
      produceMydata(dataId,dataSink)
   }
 };
 try {
  //now you can read from the InputStream the data that was written to the 
  //OutputStream
  byte[] readed=IOUtils.toByteArray(isos);
  //Use data here
 } catch (final IOException e) {
  //Handle exception here
 } finally {
  isos.close();
 }

}
}}}

=== !OutputStreamToInputStream ===
Another class that you can use if you need to write to an !OutputStream and read the data written from an !InputStream is `OutputStreamToInputStream` . It works opposite way than the previous one and allow some result to be returned after the processing of the !InputStream.

Sample usage:
{{{
final OutputStreamToInputStream<String> oStream2IStream = new OutputStreamToInputStream<String>() {
    @Override
    protected String doRead(final InputStream istream) throws Exception {
        /*
         * read from InputStream into a string. Data will be written to the outer class
         * later (oStream2IStream.write). 
         */
        final String result = IOUtils.toString(istream);
              return result + " was processed.";
        }
    };

try {   
     /*
     * some data is written to the OutputStream, will be passed to the method
     * doRead(InputStream i) above and after close() is called the results 
     * will be available through the getResults() method.
     */
     oStream2IStream.write("test".getBytes());
} finally {
     // don't miss the close (or a thread would not terminate correctly).
     oStream2IStream.close();
}
String result = oStream2IStream.getResults();
//result now contains the string "test was processed."
}}}

Behaviour in case of exception is documented in junits.
== Why !ExecutionModel ? ==
To convert an `OutputStream` into an `InputStream` you need a pipe. And to use a pipe you need Threads. [ExecutionModel Here] are io-tools options. 

=== Do and Don't Do ===

!ToBeDone.