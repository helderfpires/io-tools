#summary How to read data written to an OutputStream from an InputStream.
#labels Featured

= Introduction =

Sometimes a library writes its results to an `OutputStream` and you need to read them back from an `InputStream`. The common answer is "use pipes". But it's not as easy at is seems. Classes in the com.iotools.stream package should help.

= Details =
This code was inspired by the following article: http://ostermiller.org/convert_java_outputstream_inputstream.html

Two main classes in this section are `InputStreamFromOutputStream` and `OutputStreamToInputStream`

== !InputStreamFromOutputStream ==
This abstract class must be extended and the metod produce() implemented.
The data who is produced inside the function produce() is written to an `OutputStream` and can be readed back from from this class.
This is the preferred way to convert data written from an `OutputStream` into an `InputStream`, because the behaviour of the code tends to be more clear.

Sample usage:

{{{

final String dataId=//id of some data.
final InputStreamFromOutputStream isos = new InputStreamFromOutputStream() {
   @Override
   public void produce(final OutputStream dataSink) throws Exception {
      /*
       * call your application function who produces the data here
       * WARNING: we're in another thread here, so this method shouldn't 
       * write any class field or make assumptions on the state of the class.
       */
      produceMydata(dataId,dataSink)
   }
 };
 try {
  //now you can read from the InputStream the data that was written to the 
  //OutputStream
  byte[] readed=IOUtils.toByteArray(isos);
  //Use data here
 } catch (final IOException e) {
  //Handle exception here
 } finally {
  isos.close();
 }

}
}}}

=== !OutputStream2InputStream ===

!ToBeDone.

== Why !ThreadModel ? ==
If you look the code you shout "Get me out of here!". Yes, agree. But there is a reason why it's so complicated. 

 * To convert an `OutputStream` into an `InputStream` you need a pipe. 
 * To use a pipe and avoid a sure lock you must put the 2 ends of the pipe on different Threads.
 * To use threads Java 5 offers a wide range of options, including pools of Threads. In my library i limited these options to a reasonable number and ease of use. The enum `ThreadModel` helps selecting a mode. 

=== Do and Don't Do ===

!ToBeDone.